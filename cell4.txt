# === Cell 4: Êï¥ÂêàÁâà - Êô∫ÊÖßÂø´Âèñ„ÄÅÈåØË™§ËøΩËπ§ËàáË©≥Á¥∞Áµ±Ë®àÂÑÄË°®Êùø (Safe Cache Update) ===
import pandas as pd
import re
import time
import json
import os
import requests
import ipywidgets as widgets
from datetime import datetime
from openpyxl.utils import get_column_letter
from openpyxl.styles import Alignment
from IPython.display import display, HTML, clear_output

# ==========================================
# PART 1: CONFIG & PERSISTENCE
# ==========================================
CACHE_FILE = "aer_cache.json"
NOTES_FILE = "aer_manual_notes.json"
cache_updated = False

def load_json(file_path):
    if os.path.exists(file_path):
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                return json.load(f)
        except: return {}
    return {}

def save_json(file_path, data):
    with open(file_path, 'w', encoding='utf-8') as f:
        json.dump(data, f, indent=2, ensure_ascii=False)

# Load existing data first (Preserves data for apps not being scanned today)
local_cache = load_json(CACHE_FILE)
manual_data_store = load_json(NOTES_FILE)

# Helper to check response types
def get_row_stats(txt):
    txt = str(txt).lower().strip() if txt else ""
    return {
        "is_appr": 1 if any(k in txt for k in ['approv', 'retain', 'keep']) else 0,
        "is_deny": 1 if any(k in txt for k in ['denied', 'remove', 'delete']) else 0,
        "is_chg":  1 if any(k in txt for k in ['change', 'modif']) else 0
    }

# ==========================================
# PART 2: SCANNING ENGINE
# ==========================================
if 'TARGET_APPS' not in globals() or not TARGET_APPS:
    logger.warning("‚ö†Ô∏è Ë´ãÂÖàÂú® Cell 2 ÈÅ∏Êìá AppÔºÅ")
    TARGET_APPS = []

all_responses = []
errors = []

# --- Processing Loop ---
for category, current_app_name, current_path in TARGET_APPS:
    try:
        reviewers = list_folders(site_id, current_path)
        reviewers = [r for r in reviewers if r['name'] not in ["Forms", "_private"] and "audit" not in r['name'].lower()]
        
        logger.info(f"üöÄ Processing: {current_app_name} | Users: {len(reviewers)}")
        
        for folder in reviewers:
            reviewer_name = folder["name"]
            folder_url = folder["webUrl"]
            folder_path = f"{current_path}/{reviewer_name}"
            
            for attempt in range(2):
                try:
                    excel_files = list_excel_files(site_id, folder_path)
                    target_files = [f for f in excel_files if reviewer_name.lower() in f["name"].lower()]
                    
                    if not target_files:
                        valid_excels = [f for f in excel_files if not f["name"].startswith("~$")]
                        if not valid_excels: 
                            raise FileNotFoundError("No Excel file found")
                        target_file = valid_excels[0]
                    else:
                        target_file = target_files[0]
                    
                    file_name = target_file["name"]
                    remote_mod_time = target_file.get("lastModifiedDateTime")
                    
                    # --- CACHE CHECK ---
                    cache_key = f"{category}|{current_app_name}|{reviewer_name}"
                    cached_entry = local_cache.get(cache_key)
                    
                    is_hit = False
                    if isinstance(cached_entry, dict) and cached_entry.get('last_mod') == remote_mod_time:
                        is_hit = True
                        stats_snapshot = cached_entry.get('stats', {'Appr':0, 'Deny':0, 'Chg':0})
                    elif isinstance(cached_entry, str) and cached_entry == remote_mod_time:
                        is_hit = False # Force update for old format
                        
                    if is_hit:
                        logger.info(f"  ‚è≠Ô∏è Skipped (Cached): {reviewer_name}")
                        all_responses.append({
                            "Category": category, "App_Name": current_app_name,
                            "reviewer": reviewer_name, "response": "Cached - Completed", 
                            "is_missing": False, "row_number": 0, "file_name": file_name, "folder_url": folder_url,
                            "Audit_History": "Cached", "Last_Modified": remote_mod_time,
                            "stats_appr": stats_snapshot['Appr'],
                            "stats_deny": stats_snapshot['Deny'],
                            "stats_chg": stats_snapshot['Chg']
                        })
                        break 
                    
                    # --- DOWNLOAD & PARSE ---
                    content = download_file(site_id, f"{folder_path}/{file_name}")
                    rows = read_visible_rows(content, reviewer_name, file_name, folder_url)
                    
                    # Calculate Stats
                    miss_cnt = 0
                    s_appr, s_deny, s_chg = 0, 0, 0
                    for r in rows:
                        if r['is_missing']: miss_cnt += 1
                        st = get_row_stats(r['response'])
                        s_appr += st['is_appr']; s_deny += st['is_deny']; s_chg += st['is_chg']
                        r.update({
                            "Category": category, "App_Name": current_app_name,
                            "Audit_History": get_file_audit_log(site_id, target_file["id"]), 
                            "Last_Modified": remote_mod_time,
                            "stats_appr": st['is_appr'], "stats_deny": st['is_deny'], "stats_chg": st['is_chg']
                        })
                    
                    all_responses.extend(rows)
                    logger.info(f"  ‚úÖ Read: {reviewer_name} (Miss: {miss_cnt})")
                    
                    # Update Cache in memory (only for current app)
                    if miss_cnt == 0 and len(rows) > 0:
                        local_cache[cache_key] = {
                            "last_mod": remote_mod_time,
                            "stats": {"Appr": s_appr, "Deny": s_deny, "Chg": s_chg}
                        }
                        cache_updated = True
                    break 

                except Exception as e:
                    if attempt == 0: time.sleep(1)
                    else:
                        logger.error(f"  ‚ùå Failed {reviewer_name}: {e}")
                        errors.append({
                            "Category": category, "App_Name": current_app_name, 
                            "reviewer": reviewer_name, "error": str(e), "folder_url": folder_url
                        })
    except Exception as e:
        logger.error(f"‚ùå App Error ({current_app_name}): {e}")

if cache_updated:
    # Safely save the full cache (including apps not scanned today)
    save_json(CACHE_FILE, local_cache)
    logger.info("üíæ Cache updated safely.")

# ==========================================
# PART 3: AGGREGATION
# ==========================================
df = pd.DataFrame(all_responses)
today_str = datetime.now().strftime("%Y-%m-%d")
output_dir = f"output/{today_str}"
os.makedirs(output_dir, exist_ok=True)

unified_data = {}

def get_app_node(cat, app):
    key = f"{cat} > {app}"
    if key not in unified_data:
        # Load from persisted store
        saved_app = manual_data_store.get(key, {})
        unified_data[key] = {
            "Category": cat, "App_Name": app, 
            "status_manual": saved_app.get("app_status", "Calculated"), 
            "note_manual": saved_app.get("app_note", ""), 
            "reviewers": {}, "stats": {"total_users": 0, "completed_users": 0}
        }
    return unified_data[key]

# Process Success
if not df.empty:
    stats = df.groupby(["Category", "App_Name", "reviewer"]).agg(
        missing=("is_missing", "sum"),
        approved=("stats_appr", "sum"),
        denied=("stats_deny", "sum"),
        changed=("stats_chg", "sum")
    ).reset_index()

    for _, row in stats.iterrows():
        node = get_app_node(row['Category'], row['App_Name'])
        rev_key = row['reviewer']
        
        is_done = (row['missing'] == 0)
        node['stats']['total_users'] += 1
        if is_done: node['stats']['completed_users'] += 1
        
        saved_rev = manual_data_store.get(f"{node['Category']} > {node['App_Name']}", {}).get("reviewers", {}).get(rev_key, {})
        
        status_calc = "‚úÖ Completed" if is_done else f"‚ùå Pending: {row['missing']}"
        detail_str = f"Appr:{int(row['approved'])} | Deny:{int(row['denied'])} | Chg:{int(row['changed'])}"
        
        node['reviewers'][rev_key] = {
            "status_calc": status_calc, "detail_str": detail_str,
            "missing_cnt": row['missing'],
            "stats": {"Appr": row['approved'], "Deny": row['denied'], "Chg": row['changed']},
            "override": saved_rev.get("override", "-"), "note": saved_rev.get("note", ""),
            "error_msg": "", "folder_url": df[(df['App_Name'] == row['App_Name']) & (df['reviewer'] == rev_key)].iloc[0].get('folder_url', '#')
        }

# Process Errors
for err in errors:
    node = get_app_node(err['Category'], err['App_Name'])
    rev_key = err['reviewer']
    node['stats']['total_users'] += 1
    
    saved_rev = manual_data_store.get(f"{node['Category']} > {node['App_Name']}", {}).get("reviewers", {}).get(rev_key, {})
    
    if rev_key in node['reviewers']:
        node['reviewers'][rev_key]['error_msg'] += f"; {err['error']}"
        node['reviewers'][rev_key]['status_calc'] = "‚ö†Ô∏è Partial Error"
    else:
        node['reviewers'][rev_key] = {
            "status_calc": "‚õî Failed to Read",
            "detail_str": f"<span style='color:red'>{err['error']}</span>",
            "missing_cnt": -1, "stats": {"Appr": 0, "Deny": 0, "Chg": 0},
            "override": saved_rev.get("override", "-"), "note": saved_rev.get("note", ""),
            "error_msg": err['error'], "folder_url": err.get('folder_url', '#')
        }

# ==========================================
# PART 4: DASHBOARD UI
# ==========================================
widget_store = {} 

def build_dashboard():
    container = widgets.VBox(layout=widgets.Layout(width='100%'))
    btn_export = widgets.Button(description="üíæ Save Final Report", button_style='success', icon='file-excel', layout=widgets.Layout(width='200px'))
    lbl_out = widgets.Label(value="")
    
    app_widgets = []
    
    for app_key in sorted(unified_data.keys()):
        app_data = unified_data[app_key]
        comp = app_data['stats']['completed_users']
        tot = app_data['stats']['total_users']
        pct = int((comp / tot * 100)) if tot > 0 else 0
        header_color = "#e6ffe6" if comp == tot and tot > 0 else "#fff3e6"
        
        w_lbl = widgets.HTML(f"<b>üìÇ {app_key}</b> &nbsp;&nbsp; <span style='background:white; border:1px solid #ccc; padding:2px 6px; border-radius:4px; font-size:11px'>‚úÖ {comp}/{tot} ({pct}%)</span>", layout=widgets.Layout(width='350px'))
        w_status = widgets.Dropdown(options=["Calculated", "Force Completed", "N/A", "Action Required"], value=app_data['status_manual'], layout=widgets.Layout(width='150px'))
        w_note = widgets.Text(value=app_data['note_manual'], placeholder="App Note...", layout=widgets.Layout(width='200px'))
        
        widget_store[app_key] = {"data": app_data, "w_stat": w_status, "w_note": w_note, "revs": {}}
        
        rev_rows = [widgets.HBox([
            widgets.HTML("<b>Reviewer</b>", layout=widgets.Layout(width='180px')),
            widgets.HTML("<b>Status</b>", layout=widgets.Layout(width='140px')),
            widgets.HTML("<b>Breakdown / Error</b>", layout=widgets.Layout(width='250px')),
            widgets.HTML("<b>Override</b>", layout=widgets.Layout(width='120px')),
            widgets.HTML("<b>Note</b>", layout=widgets.Layout(width='180px'))
        ])]
        
        for r_name, r_d in app_data['reviewers'].items():
            color = "#333"; bg = "white"
            if "Failed" in r_d['status_calc']: color = "red"; bg="#fff0f0"
            elif "Pending" in r_d['status_calc']: color = "darkorange"
            elif "Completed" in r_d['status_calc']: color = "green"
            
            w_r_name = widgets.HTML(f"<a href='{r_d['folder_url']}' target='_blank' style='color:{color}; text-decoration:none'>{r_name}</a>", layout=widgets.Layout(width='180px'))
            w_r_st = widgets.HTML(f"<span style='color:{color}'>{r_d['status_calc']}</span>", layout=widgets.Layout(width='140px'))
            w_r_det = widgets.HTML(f"<span style='font-size:11px'>{r_d['detail_str']}</span>", layout=widgets.Layout(width='250px'))
            w_ovr = widgets.Dropdown(options=["-", "Mark Done", "Extension", "Escalated"], value=r_d['override'], layout=widgets.Layout(width='120px'))
            w_rn = widgets.Text(value=r_d['note'], placeholder="...", layout=widgets.Layout(width='180px'))
            
            widget_store[app_key]['revs'][r_name] = {"w_ovr": w_ovr, "w_note": w_rn, "sys": r_d}
            rev_rows.append(widgets.HBox([w_r_name, w_r_st, w_r_det, w_ovr, w_rn], layout=widgets.Layout(background_color=bg, border='1px solid #f4f4f4')))
            
        app_head = widgets.HBox([w_lbl, w_status, w_note], layout=widgets.Layout(background_color=header_color, padding="8px", border="1px solid #ccc"))
        app_body = widgets.VBox(rev_rows, layout=widgets.Layout(padding="5px 0 10px 20px"))
        app_widgets.append(widgets.VBox([app_head, app_body], layout=widgets.Layout(margin="10px 0")))

    # --- SAVE LOGIC (PRESERVES DATA) ---
    def export(b):
        b.disabled=True; b.description="Saving..."
        data_rows = []
        ts = datetime.now().strftime("%H%M%S")
        
        # 1. LOAD existing data (CRITICAL step to preserve off-screen apps)
        persist_store = load_json(NOTES_FILE)
        
        # 2. UPDATE with current screen data
        for k, v in widget_store.items():
            app_s = v['w_stat'].value
            app_n = v['w_note'].value
            persist_store[k] = {"app_status": app_s, "app_note": app_n, "reviewers": {}}
            
            for rk, rv in v['revs'].items():
                ovr = rv['w_ovr'].value
                nt = rv['w_note'].value
                persist_store[k]["reviewers"][rk] = {"override": ovr, "note": nt}
                
                final = app_s if app_s != "Calculated" else (ovr if ovr != "-" else rv['sys']['status_calc'])
                
                data_rows.append({
                    "Category": v['data']['Category'], "App Name": v['data']['App_Name'], "Reviewer": rk,
                    "System Status": rv['sys']['status_calc'], "Error Message": rv['sys']['error_msg'],
                    "Approved": rv['sys']['stats']['Appr'], "Denied": rv['sys']['stats']['Deny'], "Changes": rv['sys']['stats']['Chg'],
                    "Missing Items": rv['sys']['missing_cnt'], "Manual Override": ovr, "Final Status": final, 
                    "Note": nt, "App Note": app_n, "Folder Link": rv['sys']['folder_url']
                })
        
        # 3. SAVE full store
        save_json(NOTES_FILE, persist_store)
        
        if data_rows:
            f = f"{output_dir}/Report_{ts}.xlsx"
            pd.DataFrame(data_rows).to_excel(f, index=False)
            lbl_out.value = "Saved!"
            display(HTML(f"‚úÖ Report: <a href='{f}' target='_blank'>{f}</a>"))
        
        b.disabled=False; b.description="üíæ Save Final Report"

    btn_export.on_click(export)
    display(widgets.HBox([btn_export, lbl_out]))
    container.children = tuple(app_widgets)
    display(container)

if unified_data:
    build_dashboard()
else:
    display(HTML("<b>‚ö†Ô∏è No data found.</b>"))